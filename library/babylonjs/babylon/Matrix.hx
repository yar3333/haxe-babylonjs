package babylon;

extern class Matrix
{
	private static var _tempQuaternion : Dynamic/*UNKNOW_TYPE*/;
	private static var _xAxis : Dynamic/*UNKNOW_TYPE*/;
	private static var _yAxis : Dynamic/*UNKNOW_TYPE*/;
	private static var _zAxis : Dynamic/*UNKNOW_TYPE*/;
	var m : Float32Array;
	function isIdentity() : Bool;
	function determinant() : Float;
	function toArray() : Float32Array;
	function asArray() : Float32Array;
	function invert() : Matrix;
	function reset() : Matrix;
	function add(other:Matrix) : Matrix;
	function addToRef(other:Matrix, result:Matrix) : Matrix;
	function addToSelf(other:Matrix) : Matrix;
	function invertToRef(other:Matrix) : Matrix;
	function setTranslation(vector3:Vector3) : Matrix;
	function getTranslation() : Vector3;
	function multiply(other:Matrix) : Matrix;
	function copyFrom(other:Matrix) : Matrix;
	function copyToArray(array:Float32Array, ?offset:Float) : Matrix;
	function multiplyToRef(other:Matrix, result:Matrix) : Matrix;
	function multiplyToArray(other:Matrix, result:Float32Array, offset:Float) : Matrix;
	function equals(value:Matrix) : Bool;
	function clone() : Matrix;
	function getClassName() : String;
	function getHashCode() : Float;
	function decompose(scale:Vector3, rotation:Quaternion, translation:Vector3) : Bool;
	function getRotationMatrix() : Matrix;
	function getRotationMatrixToRef(result:Matrix) : Void;
	static function FromArray(array:Array<Float>, ?offset:Float) : Matrix;
	static function FromArrayToRef(array:Array<Float>, offset:Float, result:Matrix) : Void;
	static function FromFloat32ArrayToRefScaled(array:Float32Array, offset:Float, scale:Float, result:Matrix) : Void;
	static function FromValuesToRef(initialM11:Float, initialM12:Float, initialM13:Float, initialM14:Float, initialM21:Float, initialM22:Float, initialM23:Float, initialM24:Float, initialM31:Float, initialM32:Float, initialM33:Float, initialM34:Float, initialM41:Float, initialM42:Float, initialM43:Float, initialM44:Float, result:Matrix) : Void;
	function getRow(index:Float) : Vector4;
	function setRow(index:Float, row:Vector4) : Matrix;
	static function FromValues(initialM11:Float, initialM12:Float, initialM13:Float, initialM14:Float, initialM21:Float, initialM22:Float, initialM23:Float, initialM24:Float, initialM31:Float, initialM32:Float, initialM33:Float, initialM34:Float, initialM41:Float, initialM42:Float, initialM43:Float, initialM44:Float) : Matrix;
	static function Compose(scale:Vector3, rotation:Quaternion, translation:Vector3) : Matrix;
	static function Identity() : Matrix;
	static function IdentityToRef(result:Matrix) : Void;
	static function Zero() : Matrix;
	static function RotationX(angle:Float) : Matrix;
	static function Invert(source:Matrix) : Matrix;
	static function RotationXToRef(angle:Float, result:Matrix) : Void;
	static function RotationY(angle:Float) : Matrix;
	static function RotationYToRef(angle:Float, result:Matrix) : Void;
	static function RotationZ(angle:Float) : Matrix;
	static function RotationZToRef(angle:Float, result:Matrix) : Void;
	static function RotationAxis(axis:Vector3, angle:Float) : Matrix;
	static function RotationAxisToRef(axis:Vector3, angle:Float, result:Matrix) : Void;
	static function RotationYawPitchRoll(yaw:Float, pitch:Float, roll:Float) : Matrix;
	static function RotationYawPitchRollToRef(yaw:Float, pitch:Float, roll:Float, result:Matrix) : Void;
	static function Scaling(x:Float, y:Float, z:Float) : Matrix;
	static function ScalingToRef(x:Float, y:Float, z:Float, result:Matrix) : Void;
	static function Translation(x:Float, y:Float, z:Float) : Matrix;
	static function TranslationToRef(x:Float, y:Float, z:Float, result:Matrix) : Void;
	static function Lerp(startValue:Matrix, endValue:Matrix, gradient:Float) : Matrix;
	static function DecomposeLerp(startValue:Matrix, endValue:Matrix, gradient:Float) : Matrix;
	static function LookAtLH(eye:Vector3, target:Vector3, up:Vector3) : Matrix;
	static function LookAtLHToRef(eye:Vector3, target:Vector3, up:Vector3, result:Matrix) : Void;
	static function LookAtRH(eye:Vector3, target:Vector3, up:Vector3) : Matrix;
	static function LookAtRHToRef(eye:Vector3, target:Vector3, up:Vector3, result:Matrix) : Void;
	static function OrthoLH(width:Float, height:Float, znear:Float, zfar:Float) : Matrix;
	static function OrthoLHToRef(width:Float, height:Float, znear:Float, zfar:Float, result:Matrix) : Void;
	static function OrthoOffCenterLH(left:Float, right:Float, bottom:Float, top:Float, znear:Float, zfar:Float) : Matrix;
	static function OrthoOffCenterLHToRef(left:Float, right:Dynamic, bottom:Float, top:Float, znear:Float, zfar:Float, result:Matrix) : Void;
	static function OrthoOffCenterRH(left:Float, right:Float, bottom:Float, top:Float, znear:Float, zfar:Float) : Matrix;
	static function OrthoOffCenterRHToRef(left:Float, right:Dynamic, bottom:Float, top:Float, znear:Float, zfar:Float, result:Matrix) : Void;
	static function PerspectiveLH(width:Float, height:Float, znear:Float, zfar:Float) : Matrix;
	static function PerspectiveFovLH(fov:Float, aspect:Float, znear:Float, zfar:Float) : Matrix;
	static function PerspectiveFovLHToRef(fov:Float, aspect:Float, znear:Float, zfar:Float, result:Matrix, ?isVerticalFovFixed:Bool) : Void;
	static function PerspectiveFovRH(fov:Float, aspect:Float, znear:Float, zfar:Float) : Matrix;
	static function PerspectiveFovRHToRef(fov:Float, aspect:Float, znear:Float, zfar:Float, result:Matrix, ?isVerticalFovFixed:Bool) : Void;
	static function PerspectiveFovWebVRToRef(fov:Dynamic, znear:Float, zfar:Float, result:Matrix, ?isVerticalFovFixed:Bool) : Void;
	static function GetFinalMatrix(viewport:Viewport, world:Matrix, view:Matrix, projection:Matrix, zmin:Float, zmax:Float) : Matrix;
	static function GetAsMatrix2x2(matrix:Matrix) : Float32Array;
	static function GetAsMatrix3x3(matrix:Matrix) : Float32Array;
	static function Transpose(matrix:Matrix) : Matrix;
	static function Reflection(plane:Plane) : Matrix;
	static function ReflectionToRef(plane:Plane, result:Matrix) : Void;
	static function FromXYZAxesToRef(xaxis:Vector3, yaxis:Vector3, zaxis:Vector3, mat:Matrix) : Void;
	static function FromQuaternionToRef(quat:Quaternion, result:Matrix) : Void;
}